// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Recommendations.proto

#ifndef PROTOBUF_INCLUDED_Recommendations_2eproto
#define PROTOBUF_INCLUDED_Recommendations_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/unknown_field_set.h>
#include "General.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_Recommendations_2eproto 

namespace protobuf_Recommendations_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[9];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_Recommendations_2eproto
namespace sh {
namespace generated {
class Action;
class ActionDefaultTypeInternal;
extern ActionDefaultTypeInternal _Action_default_instance_;
class Demand;
class DemandDefaultTypeInternal;
extern DemandDefaultTypeInternal _Demand_default_instance_;
class Event;
class EventDefaultTypeInternal;
extern EventDefaultTypeInternal _Event_default_instance_;
class Location;
class LocationDefaultTypeInternal;
extern LocationDefaultTypeInternal _Location_default_instance_;
class Order;
class OrderDefaultTypeInternal;
extern OrderDefaultTypeInternal _Order_default_instance_;
class Recommendations;
class RecommendationsDefaultTypeInternal;
extern RecommendationsDefaultTypeInternal _Recommendations_default_instance_;
class Stats;
class StatsDefaultTypeInternal;
extern StatsDefaultTypeInternal _Stats_default_instance_;
class Task;
class TaskDefaultTypeInternal;
extern TaskDefaultTypeInternal _Task_default_instance_;
class Trip;
class TripDefaultTypeInternal;
extern TripDefaultTypeInternal _Trip_default_instance_;
}  // namespace generated
}  // namespace sh
namespace google {
namespace protobuf {
template<> ::sh::generated::Action* Arena::CreateMaybeMessage<::sh::generated::Action>(Arena*);
template<> ::sh::generated::Demand* Arena::CreateMaybeMessage<::sh::generated::Demand>(Arena*);
template<> ::sh::generated::Event* Arena::CreateMaybeMessage<::sh::generated::Event>(Arena*);
template<> ::sh::generated::Location* Arena::CreateMaybeMessage<::sh::generated::Location>(Arena*);
template<> ::sh::generated::Order* Arena::CreateMaybeMessage<::sh::generated::Order>(Arena*);
template<> ::sh::generated::Recommendations* Arena::CreateMaybeMessage<::sh::generated::Recommendations>(Arena*);
template<> ::sh::generated::Stats* Arena::CreateMaybeMessage<::sh::generated::Stats>(Arena*);
template<> ::sh::generated::Task* Arena::CreateMaybeMessage<::sh::generated::Task>(Arena*);
template<> ::sh::generated::Trip* Arena::CreateMaybeMessage<::sh::generated::Trip>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace sh {
namespace generated {

// ===================================================================

class Location : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sh.generated.Location) */ {
 public:
  Location();
  virtual ~Location();

  Location(const Location& from);

  inline Location& operator=(const Location& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Location(Location&& from) noexcept
    : Location() {
    *this = ::std::move(from);
  }

  inline Location& operator=(Location&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Location& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Location* internal_default_instance() {
    return reinterpret_cast<const Location*>(
               &_Location_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Location* other);
  friend void swap(Location& a, Location& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Location* New() const final {
    return CreateMaybeMessage<Location>(NULL);
  }

  Location* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Location>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Location& from);
  void MergeFrom(const Location& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Location* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sh.generated.GeoPoint geoPoint = 2;
  bool has_geopoint() const;
  void clear_geopoint();
  static const int kGeoPointFieldNumber = 2;
  private:
  const ::sh::generated::GeoPoint& _internal_geopoint() const;
  public:
  const ::sh::generated::GeoPoint& geopoint() const;
  ::sh::generated::GeoPoint* release_geopoint();
  ::sh::generated::GeoPoint* mutable_geopoint();
  void set_allocated_geopoint(::sh::generated::GeoPoint* geopoint);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sh.generated.Location)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sh::generated::GeoPoint* geopoint_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Recommendations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Event : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sh.generated.Event) */ {
 public:
  Event();
  virtual ~Event();

  Event(const Event& from);

  inline Event& operator=(const Event& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Event(Event&& from) noexcept
    : Event() {
    *this = ::std::move(from);
  }

  inline Event& operator=(Event&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Event& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Event* internal_default_instance() {
    return reinterpret_cast<const Event*>(
               &_Event_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Event* other);
  friend void swap(Event& a, Event& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Event* New() const final {
    return CreateMaybeMessage<Event>(NULL);
  }

  Event* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Event>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Event& from);
  void MergeFrom(const Event& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Event* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // .sh.generated.Location location = 2;
  bool has_location() const;
  void clear_location();
  static const int kLocationFieldNumber = 2;
  private:
  const ::sh::generated::Location& _internal_location() const;
  public:
  const ::sh::generated::Location& location() const;
  ::sh::generated::Location* release_location();
  ::sh::generated::Location* mutable_location();
  void set_allocated_location(::sh::generated::Location* location);

  // .sh.generated.TimeWindow timeWindow = 3;
  bool has_timewindow() const;
  void clear_timewindow();
  static const int kTimeWindowFieldNumber = 3;
  private:
  const ::sh::generated::TimeWindow& _internal_timewindow() const;
  public:
  const ::sh::generated::TimeWindow& timewindow() const;
  ::sh::generated::TimeWindow* release_timewindow();
  ::sh::generated::TimeWindow* mutable_timewindow();
  void set_allocated_timewindow(::sh::generated::TimeWindow* timewindow);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // int32 duration = 4;
  void clear_duration();
  static const int kDurationFieldNumber = 4;
  ::google::protobuf::int32 duration() const;
  void set_duration(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sh.generated.Event)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::sh::generated::Location* location_;
  ::sh::generated::TimeWindow* timewindow_;
  ::google::protobuf::int32 id_;
  ::google::protobuf::int32 duration_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Recommendations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Demand : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sh.generated.Demand) */ {
 public:
  Demand();
  virtual ~Demand();

  Demand(const Demand& from);

  inline Demand& operator=(const Demand& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Demand(Demand&& from) noexcept
    : Demand() {
    *this = ::std::move(from);
  }

  inline Demand& operator=(Demand&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Demand& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Demand* internal_default_instance() {
    return reinterpret_cast<const Demand*>(
               &_Demand_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(Demand* other);
  friend void swap(Demand& a, Demand& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Demand* New() const final {
    return CreateMaybeMessage<Demand>(NULL);
  }

  Demand* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Demand>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Demand& from);
  void MergeFrom(const Demand& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Demand* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sh.generated.Event events = 1;
  int events_size() const;
  void clear_events();
  static const int kEventsFieldNumber = 1;
  ::sh::generated::Event* mutable_events(int index);
  ::google::protobuf::RepeatedPtrField< ::sh::generated::Event >*
      mutable_events();
  const ::sh::generated::Event& events(int index) const;
  ::sh::generated::Event* add_events();
  const ::google::protobuf::RepeatedPtrField< ::sh::generated::Event >&
      events() const;

  // @@protoc_insertion_point(class_scope:sh.generated.Demand)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::sh::generated::Event > events_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Recommendations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Order : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sh.generated.Order) */ {
 public:
  Order();
  virtual ~Order();

  Order(const Order& from);

  inline Order& operator=(const Order& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Order(Order&& from) noexcept
    : Order() {
    *this = ::std::move(from);
  }

  inline Order& operator=(Order&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Order& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Order* internal_default_instance() {
    return reinterpret_cast<const Order*>(
               &_Order_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(Order* other);
  friend void swap(Order& a, Order& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Order* New() const final {
    return CreateMaybeMessage<Order>(NULL);
  }

  Order* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Order>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Order& from);
  void MergeFrom(const Order& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Order* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sh.generated.Demand demands = 2;
  int demands_size() const;
  void clear_demands();
  static const int kDemandsFieldNumber = 2;
  ::sh::generated::Demand* mutable_demands(int index);
  ::google::protobuf::RepeatedPtrField< ::sh::generated::Demand >*
      mutable_demands();
  const ::sh::generated::Demand& demands(int index) const;
  ::sh::generated::Demand* add_demands();
  const ::google::protobuf::RepeatedPtrField< ::sh::generated::Demand >&
      demands() const;

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sh.generated.Order)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::sh::generated::Demand > demands_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Recommendations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Task : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sh.generated.Task) */ {
 public:
  Task();
  virtual ~Task();

  Task(const Task& from);

  inline Task& operator=(const Task& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Task(Task&& from) noexcept
    : Task() {
    *this = ::std::move(from);
  }

  inline Task& operator=(Task&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Task& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Task* internal_default_instance() {
    return reinterpret_cast<const Task*>(
               &_Task_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Task* other);
  friend void swap(Task& a, Task& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Task* New() const final {
    return CreateMaybeMessage<Task>(NULL);
  }

  Task* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Task>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Task& from);
  void MergeFrom(const Task& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Task* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sh.generated.Order orders = 3;
  int orders_size() const;
  void clear_orders();
  static const int kOrdersFieldNumber = 3;
  ::sh::generated::Order* mutable_orders(int index);
  ::google::protobuf::RepeatedPtrField< ::sh::generated::Order >*
      mutable_orders();
  const ::sh::generated::Order& orders(int index) const;
  ::sh::generated::Order* add_orders();
  const ::google::protobuf::RepeatedPtrField< ::sh::generated::Order >&
      orders() const;

  // .sh.generated.SearchParams params = 2;
  bool has_params() const;
  void clear_params();
  static const int kParamsFieldNumber = 2;
  private:
  const ::sh::generated::SearchParams& _internal_params() const;
  public:
  const ::sh::generated::SearchParams& params() const;
  ::sh::generated::SearchParams* release_params();
  ::sh::generated::SearchParams* mutable_params();
  void set_allocated_params(::sh::generated::SearchParams* params);

  // int32 id = 1;
  void clear_id();
  static const int kIdFieldNumber = 1;
  ::google::protobuf::int32 id() const;
  void set_id(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sh.generated.Task)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::sh::generated::Order > orders_;
  ::sh::generated::SearchParams* params_;
  ::google::protobuf::int32 id_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Recommendations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Action : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sh.generated.Action) */ {
 public:
  Action();
  virtual ~Action();

  Action(const Action& from);

  inline Action& operator=(const Action& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Action(Action&& from) noexcept
    : Action() {
    *this = ::std::move(from);
  }

  inline Action& operator=(Action&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Action& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Action* internal_default_instance() {
    return reinterpret_cast<const Action*>(
               &_Action_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(Action* other);
  friend void swap(Action& a, Action& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Action* New() const final {
    return CreateMaybeMessage<Action>(NULL);
  }

  Action* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Action>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Action& from);
  void MergeFrom(const Action& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Action* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 eventId = 1;
  void clear_eventid();
  static const int kEventIdFieldNumber = 1;
  ::google::protobuf::int32 eventid() const;
  void set_eventid(::google::protobuf::int32 value);

  // int32 timeStart = 2;
  void clear_timestart();
  static const int kTimeStartFieldNumber = 2;
  ::google::protobuf::int32 timestart() const;
  void set_timestart(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sh.generated.Action)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 eventid_;
  ::google::protobuf::int32 timestart_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Recommendations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Stats : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sh.generated.Stats) */ {
 public:
  Stats();
  virtual ~Stats();

  Stats(const Stats& from);

  inline Stats& operator=(const Stats& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Stats(Stats&& from) noexcept
    : Stats() {
    *this = ::std::move(from);
  }

  inline Stats& operator=(Stats&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Stats& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Stats* internal_default_instance() {
    return reinterpret_cast<const Stats*>(
               &_Stats_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(Stats* other);
  friend void swap(Stats& a, Stats& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Stats* New() const final {
    return CreateMaybeMessage<Stats>(NULL);
  }

  Stats* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Stats>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Stats& from);
  void MergeFrom(const Stats& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Stats* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // int32 timeSpent = 1;
  void clear_timespent();
  static const int kTimeSpentFieldNumber = 1;
  ::google::protobuf::int32 timespent() const;
  void set_timespent(::google::protobuf::int32 value);

  // int32 distanceTraveled = 2;
  void clear_distancetraveled();
  static const int kDistanceTraveledFieldNumber = 2;
  ::google::protobuf::int32 distancetraveled() const;
  void set_distancetraveled(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sh.generated.Stats)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::int32 timespent_;
  ::google::protobuf::int32 distancetraveled_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Recommendations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Trip : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sh.generated.Trip) */ {
 public:
  Trip();
  virtual ~Trip();

  Trip(const Trip& from);

  inline Trip& operator=(const Trip& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Trip(Trip&& from) noexcept
    : Trip() {
    *this = ::std::move(from);
  }

  inline Trip& operator=(Trip&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Trip& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Trip* internal_default_instance() {
    return reinterpret_cast<const Trip*>(
               &_Trip_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(Trip* other);
  friend void swap(Trip& a, Trip& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Trip* New() const final {
    return CreateMaybeMessage<Trip>(NULL);
  }

  Trip* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Trip>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Trip& from);
  void MergeFrom(const Trip& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Trip* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sh.generated.Action actions = 4;
  int actions_size() const;
  void clear_actions();
  static const int kActionsFieldNumber = 4;
  ::sh::generated::Action* mutable_actions(int index);
  ::google::protobuf::RepeatedPtrField< ::sh::generated::Action >*
      mutable_actions();
  const ::sh::generated::Action& actions(int index) const;
  ::sh::generated::Action* add_actions();
  const ::google::protobuf::RepeatedPtrField< ::sh::generated::Action >&
      actions() const;

  // .sh.generated.GeoPoint start = 2;
  bool has_start() const;
  void clear_start();
  static const int kStartFieldNumber = 2;
  private:
  const ::sh::generated::GeoPoint& _internal_start() const;
  public:
  const ::sh::generated::GeoPoint& start() const;
  ::sh::generated::GeoPoint* release_start();
  ::sh::generated::GeoPoint* mutable_start();
  void set_allocated_start(::sh::generated::GeoPoint* start);

  // .sh.generated.GeoPoint finish = 3;
  bool has_finish() const;
  void clear_finish();
  static const int kFinishFieldNumber = 3;
  private:
  const ::sh::generated::GeoPoint& _internal_finish() const;
  public:
  const ::sh::generated::GeoPoint& finish() const;
  ::sh::generated::GeoPoint* release_finish();
  ::sh::generated::GeoPoint* mutable_finish();
  void set_allocated_finish(::sh::generated::GeoPoint* finish);

  // .sh.generated.Stats stats = 5;
  bool has_stats() const;
  void clear_stats();
  static const int kStatsFieldNumber = 5;
  private:
  const ::sh::generated::Stats& _internal_stats() const;
  public:
  const ::sh::generated::Stats& stats() const;
  ::sh::generated::Stats* release_stats();
  ::sh::generated::Stats* mutable_stats();
  void set_allocated_stats(::sh::generated::Stats* stats);

  // int32 orderId = 1;
  void clear_orderid();
  static const int kOrderIdFieldNumber = 1;
  ::google::protobuf::int32 orderid() const;
  void set_orderid(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:sh.generated.Trip)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::sh::generated::Action > actions_;
  ::sh::generated::GeoPoint* start_;
  ::sh::generated::GeoPoint* finish_;
  ::sh::generated::Stats* stats_;
  ::google::protobuf::int32 orderid_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Recommendations_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Recommendations : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:sh.generated.Recommendations) */ {
 public:
  Recommendations();
  virtual ~Recommendations();

  Recommendations(const Recommendations& from);

  inline Recommendations& operator=(const Recommendations& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Recommendations(Recommendations&& from) noexcept
    : Recommendations() {
    *this = ::std::move(from);
  }

  inline Recommendations& operator=(Recommendations&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  static const ::google::protobuf::Descriptor* descriptor();
  static const Recommendations& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Recommendations* internal_default_instance() {
    return reinterpret_cast<const Recommendations*>(
               &_Recommendations_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(Recommendations* other);
  friend void swap(Recommendations& a, Recommendations& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Recommendations* New() const final {
    return CreateMaybeMessage<Recommendations>(NULL);
  }

  Recommendations* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Recommendations>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Recommendations& from);
  void MergeFrom(const Recommendations& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Recommendations* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .sh.generated.Trip recommendations = 1;
  int recommendations_size() const;
  void clear_recommendations();
  static const int kRecommendationsFieldNumber = 1;
  ::sh::generated::Trip* mutable_recommendations(int index);
  ::google::protobuf::RepeatedPtrField< ::sh::generated::Trip >*
      mutable_recommendations();
  const ::sh::generated::Trip& recommendations(int index) const;
  ::sh::generated::Trip* add_recommendations();
  const ::google::protobuf::RepeatedPtrField< ::sh::generated::Trip >&
      recommendations() const;

  // @@protoc_insertion_point(class_scope:sh.generated.Recommendations)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::sh::generated::Trip > recommendations_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  friend struct ::protobuf_Recommendations_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Location

// int32 id = 1;
inline void Location::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Location::id() const {
  // @@protoc_insertion_point(field_get:sh.generated.Location.id)
  return id_;
}
inline void Location::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:sh.generated.Location.id)
}

// .sh.generated.GeoPoint geoPoint = 2;
inline bool Location::has_geopoint() const {
  return this != internal_default_instance() && geopoint_ != NULL;
}
inline const ::sh::generated::GeoPoint& Location::_internal_geopoint() const {
  return *geopoint_;
}
inline const ::sh::generated::GeoPoint& Location::geopoint() const {
  const ::sh::generated::GeoPoint* p = geopoint_;
  // @@protoc_insertion_point(field_get:sh.generated.Location.geoPoint)
  return p != NULL ? *p : *reinterpret_cast<const ::sh::generated::GeoPoint*>(
      &::sh::generated::_GeoPoint_default_instance_);
}
inline ::sh::generated::GeoPoint* Location::release_geopoint() {
  // @@protoc_insertion_point(field_release:sh.generated.Location.geoPoint)
  
  ::sh::generated::GeoPoint* temp = geopoint_;
  geopoint_ = NULL;
  return temp;
}
inline ::sh::generated::GeoPoint* Location::mutable_geopoint() {
  
  if (geopoint_ == NULL) {
    auto* p = CreateMaybeMessage<::sh::generated::GeoPoint>(GetArenaNoVirtual());
    geopoint_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sh.generated.Location.geoPoint)
  return geopoint_;
}
inline void Location::set_allocated_geopoint(::sh::generated::GeoPoint* geopoint) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(geopoint_);
  }
  if (geopoint) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      geopoint = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, geopoint, submessage_arena);
    }
    
  } else {
    
  }
  geopoint_ = geopoint;
  // @@protoc_insertion_point(field_set_allocated:sh.generated.Location.geoPoint)
}

// -------------------------------------------------------------------

// Event

// int32 id = 1;
inline void Event::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Event::id() const {
  // @@protoc_insertion_point(field_get:sh.generated.Event.id)
  return id_;
}
inline void Event::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:sh.generated.Event.id)
}

// .sh.generated.Location location = 2;
inline bool Event::has_location() const {
  return this != internal_default_instance() && location_ != NULL;
}
inline void Event::clear_location() {
  if (GetArenaNoVirtual() == NULL && location_ != NULL) {
    delete location_;
  }
  location_ = NULL;
}
inline const ::sh::generated::Location& Event::_internal_location() const {
  return *location_;
}
inline const ::sh::generated::Location& Event::location() const {
  const ::sh::generated::Location* p = location_;
  // @@protoc_insertion_point(field_get:sh.generated.Event.location)
  return p != NULL ? *p : *reinterpret_cast<const ::sh::generated::Location*>(
      &::sh::generated::_Location_default_instance_);
}
inline ::sh::generated::Location* Event::release_location() {
  // @@protoc_insertion_point(field_release:sh.generated.Event.location)
  
  ::sh::generated::Location* temp = location_;
  location_ = NULL;
  return temp;
}
inline ::sh::generated::Location* Event::mutable_location() {
  
  if (location_ == NULL) {
    auto* p = CreateMaybeMessage<::sh::generated::Location>(GetArenaNoVirtual());
    location_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sh.generated.Event.location)
  return location_;
}
inline void Event::set_allocated_location(::sh::generated::Location* location) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete location_;
  }
  if (location) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      location = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, location, submessage_arena);
    }
    
  } else {
    
  }
  location_ = location;
  // @@protoc_insertion_point(field_set_allocated:sh.generated.Event.location)
}

// .sh.generated.TimeWindow timeWindow = 3;
inline bool Event::has_timewindow() const {
  return this != internal_default_instance() && timewindow_ != NULL;
}
inline const ::sh::generated::TimeWindow& Event::_internal_timewindow() const {
  return *timewindow_;
}
inline const ::sh::generated::TimeWindow& Event::timewindow() const {
  const ::sh::generated::TimeWindow* p = timewindow_;
  // @@protoc_insertion_point(field_get:sh.generated.Event.timeWindow)
  return p != NULL ? *p : *reinterpret_cast<const ::sh::generated::TimeWindow*>(
      &::sh::generated::_TimeWindow_default_instance_);
}
inline ::sh::generated::TimeWindow* Event::release_timewindow() {
  // @@protoc_insertion_point(field_release:sh.generated.Event.timeWindow)
  
  ::sh::generated::TimeWindow* temp = timewindow_;
  timewindow_ = NULL;
  return temp;
}
inline ::sh::generated::TimeWindow* Event::mutable_timewindow() {
  
  if (timewindow_ == NULL) {
    auto* p = CreateMaybeMessage<::sh::generated::TimeWindow>(GetArenaNoVirtual());
    timewindow_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sh.generated.Event.timeWindow)
  return timewindow_;
}
inline void Event::set_allocated_timewindow(::sh::generated::TimeWindow* timewindow) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(timewindow_);
  }
  if (timewindow) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      timewindow = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, timewindow, submessage_arena);
    }
    
  } else {
    
  }
  timewindow_ = timewindow;
  // @@protoc_insertion_point(field_set_allocated:sh.generated.Event.timeWindow)
}

// int32 duration = 4;
inline void Event::clear_duration() {
  duration_ = 0;
}
inline ::google::protobuf::int32 Event::duration() const {
  // @@protoc_insertion_point(field_get:sh.generated.Event.duration)
  return duration_;
}
inline void Event::set_duration(::google::protobuf::int32 value) {
  
  duration_ = value;
  // @@protoc_insertion_point(field_set:sh.generated.Event.duration)
}

// -------------------------------------------------------------------

// Demand

// repeated .sh.generated.Event events = 1;
inline int Demand::events_size() const {
  return events_.size();
}
inline void Demand::clear_events() {
  events_.Clear();
}
inline ::sh::generated::Event* Demand::mutable_events(int index) {
  // @@protoc_insertion_point(field_mutable:sh.generated.Demand.events)
  return events_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sh::generated::Event >*
Demand::mutable_events() {
  // @@protoc_insertion_point(field_mutable_list:sh.generated.Demand.events)
  return &events_;
}
inline const ::sh::generated::Event& Demand::events(int index) const {
  // @@protoc_insertion_point(field_get:sh.generated.Demand.events)
  return events_.Get(index);
}
inline ::sh::generated::Event* Demand::add_events() {
  // @@protoc_insertion_point(field_add:sh.generated.Demand.events)
  return events_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sh::generated::Event >&
Demand::events() const {
  // @@protoc_insertion_point(field_list:sh.generated.Demand.events)
  return events_;
}

// -------------------------------------------------------------------

// Order

// int32 id = 1;
inline void Order::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Order::id() const {
  // @@protoc_insertion_point(field_get:sh.generated.Order.id)
  return id_;
}
inline void Order::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:sh.generated.Order.id)
}

// repeated .sh.generated.Demand demands = 2;
inline int Order::demands_size() const {
  return demands_.size();
}
inline void Order::clear_demands() {
  demands_.Clear();
}
inline ::sh::generated::Demand* Order::mutable_demands(int index) {
  // @@protoc_insertion_point(field_mutable:sh.generated.Order.demands)
  return demands_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sh::generated::Demand >*
Order::mutable_demands() {
  // @@protoc_insertion_point(field_mutable_list:sh.generated.Order.demands)
  return &demands_;
}
inline const ::sh::generated::Demand& Order::demands(int index) const {
  // @@protoc_insertion_point(field_get:sh.generated.Order.demands)
  return demands_.Get(index);
}
inline ::sh::generated::Demand* Order::add_demands() {
  // @@protoc_insertion_point(field_add:sh.generated.Order.demands)
  return demands_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sh::generated::Demand >&
Order::demands() const {
  // @@protoc_insertion_point(field_list:sh.generated.Order.demands)
  return demands_;
}

// -------------------------------------------------------------------

// Task

// int32 id = 1;
inline void Task::clear_id() {
  id_ = 0;
}
inline ::google::protobuf::int32 Task::id() const {
  // @@protoc_insertion_point(field_get:sh.generated.Task.id)
  return id_;
}
inline void Task::set_id(::google::protobuf::int32 value) {
  
  id_ = value;
  // @@protoc_insertion_point(field_set:sh.generated.Task.id)
}

// .sh.generated.SearchParams params = 2;
inline bool Task::has_params() const {
  return this != internal_default_instance() && params_ != NULL;
}
inline const ::sh::generated::SearchParams& Task::_internal_params() const {
  return *params_;
}
inline const ::sh::generated::SearchParams& Task::params() const {
  const ::sh::generated::SearchParams* p = params_;
  // @@protoc_insertion_point(field_get:sh.generated.Task.params)
  return p != NULL ? *p : *reinterpret_cast<const ::sh::generated::SearchParams*>(
      &::sh::generated::_SearchParams_default_instance_);
}
inline ::sh::generated::SearchParams* Task::release_params() {
  // @@protoc_insertion_point(field_release:sh.generated.Task.params)
  
  ::sh::generated::SearchParams* temp = params_;
  params_ = NULL;
  return temp;
}
inline ::sh::generated::SearchParams* Task::mutable_params() {
  
  if (params_ == NULL) {
    auto* p = CreateMaybeMessage<::sh::generated::SearchParams>(GetArenaNoVirtual());
    params_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sh.generated.Task.params)
  return params_;
}
inline void Task::set_allocated_params(::sh::generated::SearchParams* params) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(params_);
  }
  if (params) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      params = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, params, submessage_arena);
    }
    
  } else {
    
  }
  params_ = params;
  // @@protoc_insertion_point(field_set_allocated:sh.generated.Task.params)
}

// repeated .sh.generated.Order orders = 3;
inline int Task::orders_size() const {
  return orders_.size();
}
inline void Task::clear_orders() {
  orders_.Clear();
}
inline ::sh::generated::Order* Task::mutable_orders(int index) {
  // @@protoc_insertion_point(field_mutable:sh.generated.Task.orders)
  return orders_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sh::generated::Order >*
Task::mutable_orders() {
  // @@protoc_insertion_point(field_mutable_list:sh.generated.Task.orders)
  return &orders_;
}
inline const ::sh::generated::Order& Task::orders(int index) const {
  // @@protoc_insertion_point(field_get:sh.generated.Task.orders)
  return orders_.Get(index);
}
inline ::sh::generated::Order* Task::add_orders() {
  // @@protoc_insertion_point(field_add:sh.generated.Task.orders)
  return orders_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sh::generated::Order >&
Task::orders() const {
  // @@protoc_insertion_point(field_list:sh.generated.Task.orders)
  return orders_;
}

// -------------------------------------------------------------------

// Action

// int32 eventId = 1;
inline void Action::clear_eventid() {
  eventid_ = 0;
}
inline ::google::protobuf::int32 Action::eventid() const {
  // @@protoc_insertion_point(field_get:sh.generated.Action.eventId)
  return eventid_;
}
inline void Action::set_eventid(::google::protobuf::int32 value) {
  
  eventid_ = value;
  // @@protoc_insertion_point(field_set:sh.generated.Action.eventId)
}

// int32 timeStart = 2;
inline void Action::clear_timestart() {
  timestart_ = 0;
}
inline ::google::protobuf::int32 Action::timestart() const {
  // @@protoc_insertion_point(field_get:sh.generated.Action.timeStart)
  return timestart_;
}
inline void Action::set_timestart(::google::protobuf::int32 value) {
  
  timestart_ = value;
  // @@protoc_insertion_point(field_set:sh.generated.Action.timeStart)
}

// -------------------------------------------------------------------

// Stats

// int32 timeSpent = 1;
inline void Stats::clear_timespent() {
  timespent_ = 0;
}
inline ::google::protobuf::int32 Stats::timespent() const {
  // @@protoc_insertion_point(field_get:sh.generated.Stats.timeSpent)
  return timespent_;
}
inline void Stats::set_timespent(::google::protobuf::int32 value) {
  
  timespent_ = value;
  // @@protoc_insertion_point(field_set:sh.generated.Stats.timeSpent)
}

// int32 distanceTraveled = 2;
inline void Stats::clear_distancetraveled() {
  distancetraveled_ = 0;
}
inline ::google::protobuf::int32 Stats::distancetraveled() const {
  // @@protoc_insertion_point(field_get:sh.generated.Stats.distanceTraveled)
  return distancetraveled_;
}
inline void Stats::set_distancetraveled(::google::protobuf::int32 value) {
  
  distancetraveled_ = value;
  // @@protoc_insertion_point(field_set:sh.generated.Stats.distanceTraveled)
}

// -------------------------------------------------------------------

// Trip

// int32 orderId = 1;
inline void Trip::clear_orderid() {
  orderid_ = 0;
}
inline ::google::protobuf::int32 Trip::orderid() const {
  // @@protoc_insertion_point(field_get:sh.generated.Trip.orderId)
  return orderid_;
}
inline void Trip::set_orderid(::google::protobuf::int32 value) {
  
  orderid_ = value;
  // @@protoc_insertion_point(field_set:sh.generated.Trip.orderId)
}

// .sh.generated.GeoPoint start = 2;
inline bool Trip::has_start() const {
  return this != internal_default_instance() && start_ != NULL;
}
inline const ::sh::generated::GeoPoint& Trip::_internal_start() const {
  return *start_;
}
inline const ::sh::generated::GeoPoint& Trip::start() const {
  const ::sh::generated::GeoPoint* p = start_;
  // @@protoc_insertion_point(field_get:sh.generated.Trip.start)
  return p != NULL ? *p : *reinterpret_cast<const ::sh::generated::GeoPoint*>(
      &::sh::generated::_GeoPoint_default_instance_);
}
inline ::sh::generated::GeoPoint* Trip::release_start() {
  // @@protoc_insertion_point(field_release:sh.generated.Trip.start)
  
  ::sh::generated::GeoPoint* temp = start_;
  start_ = NULL;
  return temp;
}
inline ::sh::generated::GeoPoint* Trip::mutable_start() {
  
  if (start_ == NULL) {
    auto* p = CreateMaybeMessage<::sh::generated::GeoPoint>(GetArenaNoVirtual());
    start_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sh.generated.Trip.start)
  return start_;
}
inline void Trip::set_allocated_start(::sh::generated::GeoPoint* start) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(start_);
  }
  if (start) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      start = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, start, submessage_arena);
    }
    
  } else {
    
  }
  start_ = start;
  // @@protoc_insertion_point(field_set_allocated:sh.generated.Trip.start)
}

// .sh.generated.GeoPoint finish = 3;
inline bool Trip::has_finish() const {
  return this != internal_default_instance() && finish_ != NULL;
}
inline const ::sh::generated::GeoPoint& Trip::_internal_finish() const {
  return *finish_;
}
inline const ::sh::generated::GeoPoint& Trip::finish() const {
  const ::sh::generated::GeoPoint* p = finish_;
  // @@protoc_insertion_point(field_get:sh.generated.Trip.finish)
  return p != NULL ? *p : *reinterpret_cast<const ::sh::generated::GeoPoint*>(
      &::sh::generated::_GeoPoint_default_instance_);
}
inline ::sh::generated::GeoPoint* Trip::release_finish() {
  // @@protoc_insertion_point(field_release:sh.generated.Trip.finish)
  
  ::sh::generated::GeoPoint* temp = finish_;
  finish_ = NULL;
  return temp;
}
inline ::sh::generated::GeoPoint* Trip::mutable_finish() {
  
  if (finish_ == NULL) {
    auto* p = CreateMaybeMessage<::sh::generated::GeoPoint>(GetArenaNoVirtual());
    finish_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sh.generated.Trip.finish)
  return finish_;
}
inline void Trip::set_allocated_finish(::sh::generated::GeoPoint* finish) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(finish_);
  }
  if (finish) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      finish = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, finish, submessage_arena);
    }
    
  } else {
    
  }
  finish_ = finish;
  // @@protoc_insertion_point(field_set_allocated:sh.generated.Trip.finish)
}

// repeated .sh.generated.Action actions = 4;
inline int Trip::actions_size() const {
  return actions_.size();
}
inline void Trip::clear_actions() {
  actions_.Clear();
}
inline ::sh::generated::Action* Trip::mutable_actions(int index) {
  // @@protoc_insertion_point(field_mutable:sh.generated.Trip.actions)
  return actions_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sh::generated::Action >*
Trip::mutable_actions() {
  // @@protoc_insertion_point(field_mutable_list:sh.generated.Trip.actions)
  return &actions_;
}
inline const ::sh::generated::Action& Trip::actions(int index) const {
  // @@protoc_insertion_point(field_get:sh.generated.Trip.actions)
  return actions_.Get(index);
}
inline ::sh::generated::Action* Trip::add_actions() {
  // @@protoc_insertion_point(field_add:sh.generated.Trip.actions)
  return actions_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sh::generated::Action >&
Trip::actions() const {
  // @@protoc_insertion_point(field_list:sh.generated.Trip.actions)
  return actions_;
}

// .sh.generated.Stats stats = 5;
inline bool Trip::has_stats() const {
  return this != internal_default_instance() && stats_ != NULL;
}
inline void Trip::clear_stats() {
  if (GetArenaNoVirtual() == NULL && stats_ != NULL) {
    delete stats_;
  }
  stats_ = NULL;
}
inline const ::sh::generated::Stats& Trip::_internal_stats() const {
  return *stats_;
}
inline const ::sh::generated::Stats& Trip::stats() const {
  const ::sh::generated::Stats* p = stats_;
  // @@protoc_insertion_point(field_get:sh.generated.Trip.stats)
  return p != NULL ? *p : *reinterpret_cast<const ::sh::generated::Stats*>(
      &::sh::generated::_Stats_default_instance_);
}
inline ::sh::generated::Stats* Trip::release_stats() {
  // @@protoc_insertion_point(field_release:sh.generated.Trip.stats)
  
  ::sh::generated::Stats* temp = stats_;
  stats_ = NULL;
  return temp;
}
inline ::sh::generated::Stats* Trip::mutable_stats() {
  
  if (stats_ == NULL) {
    auto* p = CreateMaybeMessage<::sh::generated::Stats>(GetArenaNoVirtual());
    stats_ = p;
  }
  // @@protoc_insertion_point(field_mutable:sh.generated.Trip.stats)
  return stats_;
}
inline void Trip::set_allocated_stats(::sh::generated::Stats* stats) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete stats_;
  }
  if (stats) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      stats = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stats, submessage_arena);
    }
    
  } else {
    
  }
  stats_ = stats;
  // @@protoc_insertion_point(field_set_allocated:sh.generated.Trip.stats)
}

// -------------------------------------------------------------------

// Recommendations

// repeated .sh.generated.Trip recommendations = 1;
inline int Recommendations::recommendations_size() const {
  return recommendations_.size();
}
inline void Recommendations::clear_recommendations() {
  recommendations_.Clear();
}
inline ::sh::generated::Trip* Recommendations::mutable_recommendations(int index) {
  // @@protoc_insertion_point(field_mutable:sh.generated.Recommendations.recommendations)
  return recommendations_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::sh::generated::Trip >*
Recommendations::mutable_recommendations() {
  // @@protoc_insertion_point(field_mutable_list:sh.generated.Recommendations.recommendations)
  return &recommendations_;
}
inline const ::sh::generated::Trip& Recommendations::recommendations(int index) const {
  // @@protoc_insertion_point(field_get:sh.generated.Recommendations.recommendations)
  return recommendations_.Get(index);
}
inline ::sh::generated::Trip* Recommendations::add_recommendations() {
  // @@protoc_insertion_point(field_add:sh.generated.Recommendations.recommendations)
  return recommendations_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::sh::generated::Trip >&
Recommendations::recommendations() const {
  // @@protoc_insertion_point(field_list:sh.generated.Recommendations.recommendations)
  return recommendations_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace generated
}  // namespace sh

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_Recommendations_2eproto
